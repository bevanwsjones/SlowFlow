from matplotlib import pyplot as plt
from post_processor import graph as gr
import numpy as np

# return string name for error metric for plotting purposes
def grid_identity(gq):
    if gq == 0:
        return str('$\zeta_{no}$')
    elif gq == 1:
        return str('$\zeta_{ue}$')
    elif gq == 2:
        return str('$\zeta_{sk}$')
        # return str('$\zeta_{no}$')
    else:
        return ValueError("Invalid grid quality selection")

# plot the cartesian
def cartesian_plotter(int_error_array, bound_error_array, h):
    # plot 1 - x-gradient error - internal cells
    golden_mean = (np.sqrt(5) - 1.0) / 2.0
    fig, axs = plt.subplots(2, 2)
    axs[0, 0].plot(h, int_error_array[:, 0, 0], '-o', label='$L_{1} norm$')
    axs[0, 0].plot(h, int_error_array[:, 1, 0], '-ok', label='$L_{2} norm$')
    axs[0, 0].plot(h, int_error_array[:, 2, 0], '-or', label='$L_{\infty} norm$')
    axs[0, 0].axline((0.005, 0.00005), (0.05, 0.0005), color='g', label='$\mathcal{O}(h)$', ls='--')
    axs[0, 0].axline((0.01, 0.0001), (0.1, 0.01), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    axs[0, 0].set(xlabel='$h$', ylabel='Internal '+r'$\varepsilon_{x}$')
    axs[0, 0].set_yscale('log')
    axs[0, 0].set_xscale('log')
    dy = np.abs(np.log10(axs[0, 0].get_ylim()[1]) - np.log10(axs[0, 0].get_ylim()[0]))
    dx = np.abs(np.log10(axs[0, 0].get_xlim()[1]) - np.log10(axs[0, 0].get_xlim()[0]))
    axs[0, 0].set_aspect((dx / dy) * golden_mean, adjustable='box')
    # axs[0, 0].set_title(r'$a )$')

    axs[1, 0].plot(h, int_error_array[:, 0, 1], '-o', label='$L_{1} norm$')
    axs[1, 0].plot(h, int_error_array[:, 1, 1], '-ok', label='$L_{2} norm$')
    axs[1, 0].plot(h, int_error_array[:, 2, 1], '-or', label='$L_{\infty} norm$')
    axs[1, 0].axline((0.01, 0.0001), (0.1, 0.001), color='g', label='$\mathcal{O}(h)$', ls='--')
    axs[1, 0].axline((0.01, 0.0001), (0.1, 0.01), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    axs[1, 0].set(xlabel='$h$', ylabel='Internal '+r'$\varepsilon_{y}$')
    axs[1, 0].set_yscale('log')
    axs[1, 0].set_xscale('log')
    axs[1, 0].set_xlim(0.8 * np.min(h), 1.2 * np.max(h))
    axs[1, 0].set_ylim(0.8 * np.min(int_error_array[:, :, 1]), 1.2 * np.max(int_error_array[:, :, 1]))
    dy = np.abs(np.log10(axs[1, 0].get_ylim()[1]) - np.log10(axs[1, 0].get_ylim()[0]))
    dx = np.abs(np.log10(axs[1, 0].get_xlim()[1]) - np.log10(axs[1, 0].get_xlim()[0]))
    axs[1, 0].set_aspect((dx / dy) * golden_mean, adjustable='box')
    # axs[1, 0].set_title(r'$c )$')

    axs[0, 1].plot(h, bound_error_array[:, 0, 0], '-o', label='$L_{1} norm$')
    axs[0, 1].plot(h, bound_error_array[:, 1, 0], '-ok', label='$L_{2} norm$')
    axs[0, 1].plot(h, bound_error_array[:, 2, 0], '-or', label='$L_{\infty} norm$')
    axs[0, 1].axline((0.01, 0.001), (0.1, 0.01), color='g', label='$\mathcal{O}(h)$', ls='--')
    axs[0, 1].axline((0.01, 0.001), (0.1, 0.1), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    axs[0, 1].set(xlabel='$h$', ylabel='Boundary '+r'$\varepsilon_{x}$')
    axs[0, 1].set_yscale('log')
    axs[0, 1].set_xscale('log')
    axs[0, 1].set_xlim(0.8 * np.min(h), 1.2 * np.max(h))
    axs[0, 1].set_ylim(0.8 * np.min(bound_error_array[:, :, 0]), 1.2 * np.max(bound_error_array[:, :, 0]))
    dy = np.abs(np.log10(axs[0, 1].get_ylim()[1]) - np.log10(axs[0, 1].get_ylim()[0]))
    dx = np.abs(np.log10(axs[0, 1].get_xlim()[1]) - np.log10(axs[0, 1].get_xlim()[0]))
    axs[0, 1].set_aspect((dx / dy) * golden_mean, adjustable='box')
    # axs[0, 1].set_title(r'$b )$')

    axs[1, 1].plot(h, bound_error_array[:, 0, 1], '-o', label='$L_{1} norm$')
    axs[1, 1].plot(h, bound_error_array[:, 1, 1], '-ok', label='$L_{2} norm$')
    axs[1, 1].plot(h, bound_error_array[:, 2, 1], '-or', label='$L_{\infty} norm$')
    axs[1, 1].axline((0.01, 0.001), (0.1, 0.01), color='g', label='$\mathcal{O}(h)$', ls='--')
    axs[1, 1].axline((0.01, 0.001), (0.1, 0.1), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    axs[1, 1].set(xlabel='$h$', ylabel='Boundary '+r'$\varepsilon_{y}$')
    axs[1, 1].set_yscale('log')
    axs[1, 1].set_xscale('log')
    axs[1, 1].set_xlim(0.8 * np.min(h), 1.2 * np.max(h))
    axs[1, 1].set_ylim(0.8 * np.min(bound_error_array[:, :, 1]), 1.2 * np.max(bound_error_array[:, :, 1]))
    dy = np.abs(np.log10(axs[1, 1].get_ylim()[1]) - np.log10(axs[1, 1].get_ylim()[0]))
    dx = np.abs(np.log10(axs[1, 1].get_xlim()[1]) - np.log10(axs[1, 1].get_xlim()[0]))
    axs[1, 1].set_aspect((dx / dy) * golden_mean, adjustable='box')
    # axs[1, 1].set_title(r'$d )$')
    fig.tight_layout()
    handles, labels = axs[0, 0].get_legend_handles_labels()
    fig.legend(handles, labels, loc='upper left', ncol=3, bbox_to_anchor=(0.4, 0.1))
    # fig.tight_layout()
    _figure_title = "2D_Structured_Cartesian_Grid_Error_Analysis"
    print("Complete")
    gr.save_plot(_figure_title)
    gr.show_plot()
    return -1

def error_plotter(bound_error_array, int_error_array, grid_quality_array, i, i_matrix, gq = 0):
    name = grid_identity(gq)
    # - x-gradient error - internal cells
    plot1 = plt.figure(1)
    plt.subplot(3, 2, 1 + 2*i)
    plt.plot(grid_quality_array[0], int_error_array[:, 0, 0], 'o',label='L1 norm')
    plt.plot(grid_quality_array[0], int_error_array[:, 1, 0], 'ok', label='L2 norm')
    plt.plot(grid_quality_array[0], int_error_array[:, 2, 0], 'or', label='Linf norm')
    plt.xlabel(name+" Metric")
    plt.ylabel("x-Gradient Cell Error")
    #plt.xscale("log")
    #plt.yscale("log")
    plt.legend()
    plt.title(str(i_matrix)+" grid")

    plt.subplot(3, 2, 2 + 2*i)
    plt.plot(grid_quality_array[0], bound_error_array[:, 0, 0], 'o',label='L1 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 1, 0], 'ok', label='L2 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 2, 0], 'or', label='Linf norm')
    plt.xlabel(name+" Metric")
    plt.ylabel("x-Gradient Cell Error")
    #plt.xscale("log")
    #plt.yscale("log")
    plt.legend()
    plt.title(str(i_matrix)+" grid")
    plt.suptitle(name +" 2D Cartesian Mesh Internal (Left) and Boundary (Right) Cells Analysis")
    plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=0.1)
    # plt.subplot(3, 2, 2 + 2*i)
    # plt.plot(grid_quality_array[0], int_error_array[:, 0, 1], 'o',label='L1 norm')
    # plt.plot(grid_quality_array[0], int_error_array[:, 1, 1], 'ok', label='L2 norm')
    # plt.plot(grid_quality_array[0], int_error_array[:, 2, 1], 'or', label='Linf norm')
    # plt.xlabel(name+" Metric")
    # plt.ylabel("y-Gradient Error")
    # #plt.xscale("log")
    # plt.yscale("log")
    # plt.legend()
    # plt.title(str(i_matrix)+" grid")

    plot2 = plt.figure(2)
    plt.subplot(3, 2, 1 + 2*i)
    plt.plot(grid_quality_array[0], bound_error_array[:, 0, 0], 'o',label='L1 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 1, 0], 'ok', label='L2 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 2, 0], 'or', label='Linf norm')
    plt.xlabel(name+" Metric")
    plt.ylabel("x-Gradient Error")
    #plt.xscale("log")
    #plt.yscale("log")
    plt.legend()
    plt.title(str(i_matrix)+" grid")

    plt.subplot(3, 2, 2 + 2*i)
    plt.plot(grid_quality_array[0], bound_error_array[:, 0, 1], 'o',label='L1 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 1, 1], 'ok', label='L2 norm')
    plt.plot(grid_quality_array[0], bound_error_array[:, 2, 1], 'or', label='Linf norm')
    plt.xlabel(name+" Metric")
    plt.ylabel("y-Gradient Error")
    #plt.xscale("log")
    #plt.yscale("log")
    plt.legend()
    plt.title(str(i_matrix)+" grid")

    plt.suptitle(name +" 2D Cartesian Mesh Boundary Cells Analysis")
    plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=0.1)
    return -1

def grid_error_refine(int_error_array, bound_error_array, h, grid_quality, gq = 0):
    name = grid_identity(gq)
    # plot 1 - x-gradient error - internal cells
    fig1, (ax, ax2) = plt.subplots(ncols=2)
    for i, i_metric in enumerate(grid_quality):
        ax.plot(h, int_error_array[i, :, 0], '-o', label=name+'='+str(i_metric))
        ax2.plot(h, bound_error_array[i, :, 0], '-o', label=name+'='+str(i_metric))
    ax.axline((0.01, 0.0001), (0.1, 0.001), color='g', label='$\mathcal{O}(h)$', ls='--')
    ax.axline((0.01, 0.0001), (0.1, 0.01), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    ax.set(xlabel='$h$', ylabel='Internal '+r'$\varepsilon_{x}$')
    ax.set_yscale('log')
    ax.set_xscale('log')
    ax.set_xlim(0.5 * np.min(h), 1.2 * np.max(h))
    ax.set_ylim(0.8 * np.min(int_error_array[:, :, 0]), 1.2 * np.max(int_error_array[:, :, 0]))
    ax.set_aspect('auto', adjustable='box')
    # plot 2 - x-gradient error - boundrary cells
    ax2.axline((0.01, 0.001), (0.1, 0.01), color='g', label='$\mathcal{O}(h)$', ls='--')
    ax2.axline((0.01, 0.001), (0.1, 0.1), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    ax2.set(xlabel='$h$', ylabel='Boundary '+r'$\varepsilon_{x}$')
    ax2.set_yscale('log')
    ax2.set_xscale('log')
    ax2.set_xlim(0.5 * np.min(h), 1.2 * np.max(h))
    ax2.set_ylim(0.8 * np.min(bound_error_array[:, :, 0]), 1.2 * np.max(bound_error_array[:, :, 0]))
    ax2.set_aspect('auto', adjustable='box')
    handles, labels = ax.get_legend_handles_labels()
    fig1.legend(handles, labels, loc='upper left', ncol=4, bbox_to_anchor=(0.35, 0.1))
    fig1.tight_layout()
    # plot 3 - y-gradient error - internal cells
    fig2, (ax, ax2) = plt.subplots(ncols=2)
    for i, i_metric in enumerate(grid_quality):
        ax.plot(h, int_error_array[i, :, 1], '-o', label=name+'='+str(i_metric))
        ax2.plot(h, bound_error_array[i, :, 1], '-o', label=name+'='+str(i_metric))
    ax.axline((0.01, 0.0001), (0.1, 0.001), color='g', label='$\mathcal{O}(h)$', ls='--')
    ax.axline((0.01, 0.0001), (0.1, 0.01), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    ax.set(xlabel='$h$', ylabel='Internal '+r'$\varepsilon_{y}$')
    ax.set_yscale('log')
    ax.set_xscale('log')
    ax.set_xlim(0.5 * np.min(h), 1.2 * np.max(h))
    ax.set_ylim(0.8 * np.min(int_error_array[:, :, 1]), 1.2 * np.max(int_error_array[:, :, 1]))
    ax.set_aspect('auto', adjustable='box')
    # plot 4 - y-gradient error - boundrary cells
    ax2.axline((0.01, 0.001), (0.1, 0.01), color='g', label='$\mathcal{O}(h)$', ls='--')
    ax2.axline((0.01, 0.01), (0.1, 1.0), color='b', label='$\mathcal{O}(h^2)$', ls='--')
    ax2.set(xlabel='$h$', ylabel='Boundary '+r'$\varepsilon_{y}$')
    ax2.set_yscale('log')
    ax2.set_xscale('log')
    ax2.set_xlim(0.5 * np.min(h), 1.2 * np.max(h))
    ax2.set_ylim(0.8 * np.min(bound_error_array[:, :, 1]), 1.2 * np.max(bound_error_array[:, :, 1]))
    ax2.set_aspect('auto', adjustable='box')
    handles, labels = ax.get_legend_handles_labels()
    fig2.legend(handles, labels, loc='upper left', ncol=4, bbox_to_anchor=(0.35, 0.1))
    fig2.tight_layout()
    return fig1, fig2

def grid_metric_plotter(bound_error_array, int_error_array, grid_quality_array, i_matrix, gq = 0):
    name = grid_identity(gq)
    # - x-gradient error - internal cells
    plt.figure(1, figsize=(6, 6))
    plt.plot(grid_quality_array[0], int_error_array[:, 0, 0], 'o:',label='$L_{1} norm$')
    plt.plot(grid_quality_array[0], int_error_array[:, 1, 0], 'ok:', label='$L_{2} norm$')
    plt.plot(grid_quality_array[0], int_error_array[:, 2, 0], 'or:', label='$L_{\infty} norm$')
    plt.xlabel(name)
    plt.ylabel('Internal ' + r'$\varepsilon_{x}$')
    plt.legend()

    plt.figure(2, figsize=(6, 6))
    plt.plot(grid_quality_array[0], bound_error_array[:, 0, 0], 'o:',label='$L_{1} norm$')
    plt.plot(grid_quality_array[0], bound_error_array[:, 1, 0], 'ok:', label='$L_{2} norm$')
    plt.plot(grid_quality_array[0], bound_error_array[:, 2, 0], 'or:', label='$L_{\infty} norm$')
    plt.xlabel(name)
    plt.ylabel('Boundary ' + r'$\varepsilon_{x}$')
    plt.legend()
    plt.tight_layout()

    plt.figure(3, figsize=(6, 6))
    plt.plot(grid_quality_array[0], int_error_array[:, 0, 1], 'o:',label='$L_{1} norm$')
    plt.plot(grid_quality_array[0], int_error_array[:, 1, 1], 'ok:', label='$L_{2} norm$')
    plt.plot(grid_quality_array[0], int_error_array[:, 2, 1], 'or:', label='$L_{\infty} norm$')
    plt.xlabel(name)
    plt.ylabel('Internal ' + r'$\varepsilon_{y}$')
    plt.legend()
    plt.tight_layout()

    plt.figure(4, figsize=(6, 6))
    plt.plot(grid_quality_array[0], bound_error_array[:, 0, 1], 'o:',label='$L_{1} norm$')
    plt.plot(grid_quality_array[0], bound_error_array[:, 1, 1], 'ok:', label='$L_{2} norm$')
    plt.plot(grid_quality_array[0], bound_error_array[:, 2, 1], 'or:', label='$L_{\infty} norm$')
    plt.xlabel(name)
    plt.ylabel('Boundary ' + r'$\varepsilon_{y}$')
    plt.legend()
    plt.tight_layout()
    return -1